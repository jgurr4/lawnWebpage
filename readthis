This project is run using Node.js, MariaDB Connector/Database, and Docker Compose.
This project has my Lawn webpage in it. It runs docker containers to run both my server with nodejs and my database with mysql, all my html/css/images static files are also run on the nodejs server.

Here is the command you run to begin docker-compose.yml:
sudo docker-compose up -d
mysql by default uses port 3306
Mariadbscript.js server connector uses port 3000 for node.
Normally I would have ports: '"3000:3000"' in docker-compose.yml and 'const port = 3000'
in mariadbscript.js, but I have it assigned to port 80 on the server/local machine so domain
name can attach to it with just the ip address. So now it has 'ports: "80:80"'
in docker-compose.yml and 'const port = 80' in mariadbscript.js.

~~
Purpose of each file:
docker-compose.yml -This starts the program. It creates two containers, a nodejs container for running the server itself on port 3306, and a mariadb container, which starts mariadb running and ready to receive queries to the database which holds the customer data.

start_mariadb  -This file is simply how I test the individual containers. It's not required in the final version of the app.
start_node     -Same thing.

Dockerfile  -This is how the nodejs app gets built. It needs to be customized more than mariadb container so that is why this is used. It's possible that it needs to be run beforehand in order for the image to be built. Or perhaps I can upload the created image to dockerhub and change docker-compose.yml use the dockerhub instead of needing this file.

init.sh  -This file is used to run my mariadb script

mariadb.sql  -This is the file that gets used by init.sh to run mariadb commands to check if the database and table exist, if they don't this runs commands which will create them so that the environment is created and ready for the web app to use.

Deploy-update   -Use this whenever you make changes to this project to make sure it updates to the web server containers as well. After you do this, you must also ssh into the web server and remove the old jaredsdev/nodejsapp image with 'docker rmi' and then run these commands:
docker-compose down
docker-compose up -d
Then it will download with the updated container and project files.


~~

For mysql: 
Guide for connecting to dockerized mysql database and begin making queries inside terminal:
    mysql -h 127.0.1.1 -u root

If you want to access inside the docker container itself then do this:
    docker exec -it mariadbtest /bin/bash

~~

For Node Dockerfile:
docker build -t nodejsapp .  -to build the image. It needs sudo to access mysql data.
docker run -d --rm --name myapp -p 3000:3000 nodejsapp  -to start to container running
curl http://docker:3000  or go to browser and type localhost:3000   -To see if it's working.
docker exec -it myapp /bin/bash   -If I need to go into container.
docker stop myapp   -how to exit and destroy(if you used --rm above) the container.
docker image rm nodejsapp  -how to destroy the image.
node server.js   -before running docker image, you can use this command to test if the app actually works outside of the docker container first.

~~

for docker-compose.yml:
  sudo docker compose up -d     -creates and starts running the containers. If you want to see why something isn't working, then do this without the '-d' option.
  docker-compose down           -stops and destroys running containers.

~~

Documenting all the issues I had and how I resolved them:

~~

#1)
insert/create a table for mysql database:
I had an error that said I had incorrect syntax. I triple checked the syntax and couldn't figure out where I went wrong, but then I remembered that there are reserved keywords. So I checked this page: https://mariadb.com/kb/en/reserved-words/ and found out interval which was a column name I was using was a reservered word. So I changed it to intervals.

Conclusion: The solution was to simply check reserved words in mariadb, and make sure I wasn't using any of them in my create table statement.

~~

#2)
I was trying to run my app from server.js, but mysqlscript.js would never run even when I used the quote.html form page. I found out, I needed to start the app with mysqlscript.js in order for it to be used, so I just copied my server.js code directly into it, (at least the parts that needed to start the server with) and then I did 
'node mysqlscript.js' and it worked perfectly.

~~

#3)
Next I was having problems getting all the values of my page into the database. I could send 1 value using this syntax: VALUES (?), username, ... but no matter how I tried adjusting that method I couldn't get it to send multiple values like email etc.. After hours of trial and error, I found a method that worked. 
Here is the solution:

app.post('/api/contact', function(req, res){
    const username=" '" + req.body.name + "'";
    const email=" '" + req.body.email + "'";
    const phone=" '" + req.body.phone + "'";
    const service=" '" + req.body.service + "'";
    const address=" '" + req.body.address + "'";
    const intervals=" '" + req.body.intervals + "'";
    const message=" '" + req.body.message + "'";
    const values = [username, email, phone, service, address, intervals, message, "           CURDATE()"];
    con.query("INSERT IGNORE INTO `contact` (name, email, phone, service, address, intervals, message, submission_date) VALUES (" + values + ")",
      function(err, res){
        if(err) throw err;
        console.log("1 record inserted");
      });
    res.redirect('back');
});

~~

#4)
This next problem I had is that when I ran 'sudo docker-compose up -d' I was able to connect to the mysql container, but when I did 'docker-compose ps' I saw that the nodeapp had exited for no real reason. It didn't tell me it had exited or that there was an error that caused it to exit. So I'll ask why this happened. 

I found out when I ran without -d option it told me more useful error info inside the node container.
It seems like the issue is that the host 127.0.1.1 is incorrect when using the docker container.
This is frustrating though, because even though I make a change to the source file in order to fix this problem, it still doesn't make the change, because it already built the image, it isn't going to keep rebuilding the image over and over, rather it's just going to start and stop the containers, and since the node container keeps exiting/crashing due to this error, I don't have a chance to fix it from the inside. 

Solution: I went inside the docker image that my app kept using to run it's containers which was called mariadb_web
	docker run -it --rm --name nodeapp mariadb_web /bin/bash
Then I found the file that I needed to change, used vim and changed it. 
Then in another tab I commited the docker containers changes to it's source image:
	docker commit nodeapp mariadb_web
Then I went back to the container I was in and did CTRL-D to exit. 
Then I ran the docker compose again and it did successfully save the changes.
However, it still didn't fix the original problem of nodeapp crashing and exiting right after it starts.

The solution was that my docker-compose.yml had been describing container_names, when it already had them listed in the file.
But then I had another problem that my program crashed because unable to access mysql using mysqlscript. So, I changed the host: "" value inside mysqlscript.js to match the name inside docker-compose.yml, which in this case was called 'db'. After that, it connected successfully, and my app was working.

~~

#5)
I tried connecting through my terminal to the mysql database first, and logged in as user root. Then when I tried using my webapp to send a customer quote data record, it failed and the app crashed, because I was already logged in as root. So it wouldn't let the app send the data, which caused a crash. As soon as you login as root, it disconnects the webapp from it, because it logs in as root when it starts.
To fix this, I simply logged out of root user on my terminal. Further solutions might be to add a user when I want to login using terminal, and to make an error occur but still continues to redirect user of webpage to a refreshed page, and make them think it still went through in case of an error.

#6)
I have an issue, that the connection to database disconnects automatically after a certain period of time. Which crashes the entire app. 

Next step is to set up a response error if the user already exists in the database, it should advise customers to call you instead or email.
Also I would like to have it set up to send me an email every time a customer submits a record in the database.

Built using this guide: https://www.katacoda.com/courses/docker/3

node server.js in order to test the app in your normal directory before running the docker container, in order to make sure it works. This is what I will use until I figure out how to restart the node server inside docker container.
One option is I may need to install the nodemon module which is supposed to automatically refresh server if it detects any changes to the files.


-mkdir /src/app because it's going to be our working directory, and because that directory automatically allows read & write permissions for the environment user. -p option makes it create the parent directories if they don't exist. If you don't do this it will have an error. 

-Assign the workdir with WORKDIR command. This is where all the files we are working with will be stored. 

-COPY package.json is used because we don't want npm install to run every single time. What happens is if there has been a change to package.json, then the cached results of npm install will be invalidated, and it won't run. But if there has not been a change to package.json, then npm install runs the cached results. This way npm install won't force a rewrite full install every single time you start this container with the build command. Alternatively: If you don't want to use the cache as part of the build then set the option --no-cache=true as part of the docker build command.

-After we have installed dependencies we now copy our source code. We do this separately to keep the source code independant from the dependencies because we only want npm install to run if there is changes to the package.json, not if there is changes to the source code beside that. This is assuming you have code already made and set up inside your current directory of your local machine.

-EXPOSE is used to open up the ports that our app needs to use in order to work.

-npm start is a useful command to start up our nodejs application and it will look inside the package.json doc to see how our app is meant to be run which avoids duplication of commands.here it is ran in 'exec' form. Which means each word in the command is placed in a json object with double quotes("") being required. 

Inside build:

-command to build image using dockerfile is 'docker build -t nodeapp .'

-command to launch the build image is 'docker run -d --name my-running-app -p 3000:3000 nodeapp'

-You can test to make sure the container works by doing 'curl http://docker:3000' and it should respond. That will show you set everything up correctly.

-Using -e option, you can set the environment variable as -e NODE_ENV=production   -This is useful because docker containers should run flawlessly no matter what the environment is, but you should specify the environment, whether it's development, staging, QA(quality assurance -normally only used by large companies) or production.
These are known as deployment environments.
These normally break down as follows: 

dev: Working code copy. Changes made by developers are deployed here so integration and features can be tested. This environment is rapidly updated and contains the most recent version of the application.

qa: (Not all companies will have this). Environment for quality assurance; this provides a less frequently changed version of the application which testers can perform checks against. This allows reporting on a common revision so developers know whether particular issues found by testers has already been corrected in the development code.

staging: This is the release candidate, and this environment is normally a mirror of the production environment. The staging area contains the "next" version of the application and is used for final stress testing and client/manager approvals before going live.

production: This is the currently released version of the application, accessible to the client/end users. This version preferably does not change except for during scheduled releases.


#7) I was having an issue like this: [Warning] Aborted connection 15 to db: 'customer' user: 'root' host: '172.23.0.3' (Got an error reading communication packets)
What I did to fix it was I removed the mysql_data folder that was there from a past container, and the image initiated a new one. Then I also made a password required for root user, and as root user I created the customer database and contact table. After that I had no more issues. Before when I did not have the password as root user, it wasn't recognizing the database I created as legitimate and the error occurred again. So I'll add mysql_data to gitignore and when I upload my app to the remote server, I'll login to the database container and create customer and contact manually like I did here. Also, I'll make sure to upload the node_modules manually rather than doing npm install on the server, because I don't know how to make a command run on starting the container to do npm install for the dependencies. 
So in summary: when uploading app to remote server:
Make sure to include these things:
node_modules/
Make sure to not to include these things from project:
mysql_data/

#8) I'm also getting this strange error:
web_1  | Error: connect ECONNREFUSED 172.23.0.2:3306
web_1  |     at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1144:16)
web_1  |  From event:
web_1  |     at _registerHandshakeCmd (/src/app/node_modules/mariadb/lib/connection.js:732:11)
web_1  |     at /src/app/node_modules/mariadb/lib/connection.js:57:11
web_1  |     at new Promise (<anonymous>)
web_1  |     at Connection.connect (/src/app/node_modules/mariadb/lib/connection.js:56:16)
web_1  |     at createConnectionPoolPromise (/src/app/node_modules/mariadb/lib/pool-promise.js:31:8)
web_1  |     at creationTryout (/src/app/node_modules/mariadb/lib/pool-base.js:352:9)
web_1  |     at listOnTimeout (internal/timers.js:551:17)
web_1  |     at processTimers (internal/timers.js:494:7) {
web_1  |   errno: -111,
web_1  |   code: 'ECONNREFUSED',
web_1  |   syscall: 'connect',
web_1  |   address: '172.23.0.2',
web_1  |   port: 3306,
web_1  |   fatal: true
web_1  | }
It doesn't crash my app though, so I'll ask about it later.
